//2 variable

let-> can be modified, local scope
const -> cannot be modified, local scope
var -> can be reassigned, global

//3 data types and operators

(1) number (doesn't have int/float)
(2) string
(3) boolean
(4) NULL (any)
(5) undefined (doesn't exist)
(6) objects ({x:'y', z:'w'})

opeartors->(+ - * /)
(string x number -> number)
(string + number -> string)

//7 functions

function a(){
    console.log(arguments)
}

//8 arrow functions

()=>{
    console.log("aaa");
}

(...ab)=>{
    console.log(ab); //can add parameters dynamically in ab
}

var: Hoisted with undefined initialization.
let and const: Hoisted but not initialized (leads to TDZ).
Function declarations: Hoisted completely, including the function body.
Function expressions: Behave like variables, so hoisting works like variable hoisting (only the declaration is hoisted, not the assignment).
In short, hoisting allows you to reference variables and functions before they're written in the code, but the behavior differs depending on whether you're using var, let, const, or function declarations.

//11 arrays high order
arr.x
(1) for each->loops on every element of array and does not return anything
    const arr = [1, 2, 3];
    arr.forEach(num => console.log(num)); 
    // Output: 1, 2, 3

(2) map->returns a new array by applying a function to each element of the array 
    const arr = [1, 2, 3];
    const newArr = arr.map(num => num * 2);
    console.log(newArr); // Output: [2, 4, 6]

(3) find
    const arr = [1, 2, 3, 4];
    const result = arr.find(num => num > 2);
    console.log(result); // Output: 3

(4) includes
    const arr = [1, 2, 3];
    console.log(arr.includes(2)); // Output: true
    console.log(arr.includes(4)); // Output: false

(5) filter
    const arr = [1, 2, 3, 4];
    const newArr = arr.filter(num => num % 2 === 0);
    console.log(newArr); // Output: [2, 4]

(6) slice
    const arr = [1, 2, 3, 4, 5];
    const newArr = arr.slice(1, 4);
    console.log(newArr); // Output: [2, 3, 4]

(7) splice->Changes the contents of an array by removing or replacing elements and/or adding new elements. arr.splice(start, deleteCount, items...(optional))
    const arr = [1, 2, 3, 4, 5];
    arr.splice(2, 2); // Removes 2 elements starting from index 2
    console.log(arr); // Output: [1, 2, 5]

    const arr = [1, 2, 3, 4];
    arr.splice(2, 0, 6, 7); // Adds 6 and 7 at index 2
    console.log(arr); // Output: [1, 2, 6, 7, 3, 4]


//12 DOM
(1)prompt->Displays a dialog box that prompts the user for input.
    let userInput = prompt("What is your name?");
    console.log(userInput); // Logs the user's input or null if cancelled.

(2)window->Represents the global context (or "global object") of the browser. It is the top-level object in the browser's JavaScript environment.
    console.log(window); // Logs the entire window object

    // Accessing properties
    console.log(window.innerWidth); // The width of the browser window
    console.log(window.location);   // The URL of the current page

    // Window methods
    window.alert("This is an alert!");


//14 DOM Manipulation
    const el = document.getElementbyId("aa");
    el.innertext="a";
    el.style.textDecoration="underline";
    el.style.colour = "red";
    el.parentElement.removeAttribute("style");  // remove all inline CSS styles that were directly written on the parent element in HTML or via JS.
    el.remove();

//16 Event Listeners

    [...document.body.children].forEach(child => {
        child.addEventListener("click", () => {
            child.remove();
        });
    });
Your code makes each child of <body> delete itself when clicked. It's a basic DOM + event listener setup that demonstrates interactivity and element manipulation.

//17 DOM Manipulation
const el = document.createElement("div");
el.innerText = "x";
container.appendChild(el); 
Gets added as the last child in container

//18 Promises
asynchronous->Asynchronous code doesn't block the rest of the program. It runs in the background, and when it's done, it gives you the result later.

const p = new Promise((resolve, reject) => {
    setTimeout(() => {
        resolve("Done");
    }, 1000);
});

p.then(result => console.log(result)); // prints "Done" after 1 sec


let res = fetch("https://...")  //promise that i will fetch it and run
[await] used on an asynic function

async function getData() {
  const res = await fetch("https://api.example.com/data"); //promise
  const data = await res.json();  //await tells JS: â€œWait until this is done before continuing."
  console.log(data);
}

fetch("---")
.then((data)=> {
    Console.log("--)"
    })

.catch(()=>{
    Console.log(error);
})

//20 Local Storage

// Save a value
localStorage.setItem("name", "Soham");

// When the page loads, get that value and use it
window.addEventListener("load", () => {
    const value = localStorage.getItem("name");
    
    const username = document.getElementById("username");
    if (username && value) {
        username.innerText = value;
    }
});


//21 Getting user's current location

button.addEventListener('click, async()=>{
    const result = navigator.geolocation.getCurrentPosition(()=>{})
})